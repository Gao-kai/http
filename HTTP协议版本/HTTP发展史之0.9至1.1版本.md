## 一、HTTP的诞生
+ 20世纪70年代发明出了著名的TCP/IP协议，该协议良好的分层结构和稳定的性能使它迅速的流行起来;
+ 20世界80年代中期TCP/IP协议进入了UNIX系统内核中，使更多的计算机接入了互联网
+ 1989年任职于欧洲核子研究中心的蒂姆·伯纳斯李提出了在互联网上构建超链接文档系统的构想，在他的论文中他创新的提出了后来改变互联网发展进程的三项技术：
	- URI：Uniform Resource Identifier 统一资源标识符，任何互联网上的资源都有一个URI
	- HTML：Hyper Text Markdown Language 超文本标记语言
	- HTTP：Hyper Text Transfer Protocal 超文本传输协议
	基于这三项技术，人们就可以把超文本系统完美的运行在互联网上，世界各地的人们都可自由的共享信息，他把这种可以在互联网上运行超文本的系统称为万维网 World Wide Web，自此HTTP协议正式诞生了。

## 二、HTTP/0.9版本
HTTP诞生之后的20世纪90年代初期，计算机处理能力低，存储容量小，网速很慢并且互联网上绝大多数的资源都是纯文本，所以HTTP的设计不可避免的受到了那个时代的限制，这是不可避免的,后来把这个阶段的HTTP定义为HTTP/0.9,是结构最简单的HTTP协议，它主要有以下功能：

1. 蒂姆伯纳斯李最初设想的系统里的文件都是只读的，所以HTTP/0.9协议只允许发送GET请求从服务器获取数据，并且服务器只可以回复HTML格式的字符串。
2. HTTP/0.9规定了服务器一旦响应请求之后就会立即关闭连接
3. HTTP/0.9规定了传输的数据只能是纯文本格式

## 三、HTTP/1.0版本
### 为什么从0.9升级到1.0版本？
1. 1992年JPEG图像格式发明和1995年MP3音乐格式的发明，使得计算机多媒体技术有了新的发展
2. 1993年世界上第一个可以图文混编的浏览器Mosaic问世
3. 1995年著名的web服务器软件Apache问世

以上新技术的出现导致越来越多的人使用互联网，研究HTTP并提出改进意见，基于用户需求的角度来看原先的HTTP/0.9协议已经不满足人们的需求，于是经过一系列的草案，HTTP/1.0版本于1996年正式发布,编号为RFC1945。

### HTTP/1.0新增内容
1. HTTP/1.0新增了POST和HEAD请求方法
2. HTTP/1.0规定每次通信都必须包括头信息(HTTP Header),头信息是采用ASCII编码的文本
3. HTTP/1.0规定头信息后面的数据实体可以是任意数据格式(MIME:多用途互联网邮件拓展),这意味着互联网除了文字之外，还可以传输图像、音频、视频、二进制文件等多种格式的数据。
4. HTTP/1.0新增了响应状态码(Status code)来标记服务端可能出现的错误原因
5. HTTP/1.0新增了多字符集的支持
6. HTTP/1.0新增了权限(Authorization)、缓存(Cache)、内容编码(Content Encoding)的概念

### HTTP/1.0的缺点：TCP连接不可复用
> 问题原因

HTTP/1.0最大的缺点就在于每个TCP连接一次只能发送一个请求，数据传输完毕之后TCP连接通道就立即关闭，如果此时要发起其他请求又需要重新建立新的TCP连接，而每次客户端和服务端建立TCP连接的成本都很高(3次握手),并且开始时发送速率比较慢(slow start)，所以总体来说HTTP/1.0版本的性能是比较差的，尤其是页面加载的外部资源越来越多的情况下。

> 这个缺点是如何被解决的？

浏览器在发起请求的时候，会使用一个非标准的请求头字段Connection字段来告诉服务器:这个请求完成之后请不要断开TCP连接，我这还需要发起新的请求来复用当前这个TCP连接。
```
Connection:keep-alive;
```

服务器在解析到这个字段之后，在响应之后就不会立即关闭TCP连接，而是同样回复这个字段告诉客户端，这次请求的TCP连接没有断开。这样子一个可被复用的TCP连接就建立起来了，知道客户端或服务器主动去关闭连接。
```
Connection:keep-alive;
```

### 影响
HTTP/1.0的发布多方面的增强了原来的HTTP/0.9版本，但是遗憾的是HTTP/1.0在当时并不是一份互联网世界公认的标准，它只是一份草案并不具备真正的约束力，但是HTTP/1.0提出的POST请求方法、引入响应状态码和Header头部等概念，一直被沿用至今，并且就是因为它的简单和易于管理的特点，使得它得到了广泛的应用。

### 举例
>客户端请求：
```
GET index.html HTTP/1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept:*/*
Accept-Encoding:gzip,deflate
Connection:keep-alive
```
>服务端响应
```
HTTP/1.0 200 OK
Content-Type:text/plain
Content-Encoding:gzip
Content-Length: 137582
Connection:keep-alive
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>
```


## 四、HTTP/1.1版本
### 为什么从1.0升级到1.1版本？
1995年网景公司的Netscape Navigator和微软的IE浏览器开始了著名的浏览器大战，最终IE取得了决定性的胜利。对于HTTP协议来说，在这场互联网的大战中它经受住了实践的检验，但是此时的HTTP/1.0协议还是一份草案并没有被标准化，所以HTTP协议的标准化变得十分必要。

1999年，IETF国际互联网工程任务组发布了RFC2616号文件，该文件规定了HTTP/1.1正式作为一个标准存在于互联网世界中，这意味着以后互联网上的所有浏览器、服务器、网关、代理等只要用到HTTP协议，就需要严格的遵守HTTP/1.1规定的标准。

### HTTP/1.1新增了那些内容？
虽然HTTP/1.1是对HTTP/1.0的小幅度修正，但还是新增了以下一些新的内容：

#### 1. HTTP/1.1默认支持持久连接(persistent Connection)
持久连接意味着TCP连接默认就是不关闭的，可以被多个请求进行复用，而且不用再显式的声明Connection；keep-alive字段了,这解决了HTTP/1.0中无法复用TCP连接的问题。
对于同一个域名，浏览器允许最多可以建立6个持久TCP连接，这也就意味向同一域名同一时刻最多可以发起6个请求，这为域名分片的优化技术打下来基础。
客户端和服务端发现对方有一段时间没有活动，就可以主动去关闭tcp连接，当然这个时间是可以设置的。
规范的做法是在客户端发起最后一个请求之后，在请求头中设置Connection:close字段来明确要求服务器在本次请求后关闭TCP连接。
```
Connection:close;
```
	
#### 2. HTTP/1.1引入了管道机制(pipelining)
这意味着在同一个TCP连接里面，客户端可以同时发送多个请求，这进一步的提高了HTTP协议的效率，解决了HTTP/1.0中一个TCP连接只能发起一个请求的问题。

比如客户端要要请求A和B两个资源：
HTTP/1.1之前的做法是：在同一个TCP连接中，先发起A请求，等待服务器响应之后收到A资源；收到之后再接着发起B请求。
HTTP/1.1的管道机制的做法是：在同一个TCP连接中，允许浏览器同时发起A和B两个请求，但是服务器还是按照顺序先回应A请求，再回应B请求。

#### 3. HTTP/1.1规定了服务器返回Content-Length字段便于客户端区分响应数据包
在HTTP/1.0中,Content-Length字段不是必需的。但是HTTP/1.1的管道机制规定了一个TCP连接现在可以响应多个请求，那么就需要有一种机制，让浏览器区分数据包是属于哪一个回应的,也就是Content-Length字段的作用：用来声明服务器本次回应的数据长度：
```
Content-Length：19854
```
上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。

#### 4. HTTP/1.1允许响应的数据进行分块发送chunked，利于传输大文件

使用Content-Length字段的前提是服务器知道自己本次响应的数据长度是多少，但是对于大文件或者比较耗时的动态操作来说，服务器要等到所有操作处理完成之后才可以知道响应数据的长度并响应，这样处理的性能不高。

正确的做法是服务端产生一块数据就先发送一块，采用流模式Stream取代原来的缓存模式buffer。因此，HTTP/1.1规定了服务端可以不使用Content-Type字段，而使用分块传输编码的方式来分块传递数据。

只要请求或者响应的头部信息中包含Transfer-Encoding字段，那么代表服务端的响应数据将会由未知数量的数据块chunk组成：每个非空的数据块之前都有一个16进制的数值，表示这个块的长度，最后是一个长度为0的块，客户端接收到这个长度为0的块就表示本次服务器响应的数据完成了。

```
Transfer-Encoding:chunked

30
this is the first chunk

15 
this is second chunk

10 
hello world

0
```

#### 5. HTTP/1.1新增了PUT、DELETE、OPTIONS、PATCH等请求方法
#### 5. HTTP/1.1规定了客户端请求的头信息中可以添加Host字段，用来指定服务器的域名
HTTP/1.0是不支持在一台服务器上搭建多个web站点的，比如无法同时在同一台服务器上托管www.baidu.com和www.hupu.com两个域名；而HTTP/1.1新增的Host字段是必传的，这意味着客户端可以将针对于不同域名的请求发往同一台服务器,为虚拟主机的兴起打下基础。





### HTTP/1.1的缺点(队头阻塞)
#### 问题原因

虽然HTTP/1.1实现了持久连接，可以复用TCP连接，但是在同一个TCP连接里面，所有数据的通信都是按照次序依次进行的，也就是说服务器必须处理完一个回应之后才会进行下一个回应，这就会导致如果某一个请求的响应时间太慢的话，那么后面的所有请求都会得不到响应处理排队等待，这就是著名的*队头阻塞Head-of-line blocking*问题。

#### 解决方案
1. 尽可能的减少请求的数量
比如合并脚本和样式表，雪碧图等，将原本需要多次请求的静态资源合并为一个大的文件一次请求下来。

2. 尽可能的同时多开一些持久连接
比如域名分片技术domain sharding。浏览器对于同一域名最大可以维护6个持久TCP连接，如果将域名分片为多个域名，那么就可以实现更多的tcp持久连接。

### 简述HTTP1.0和HTTP1.1的区别
1. HTTP1.0在请求完成之后会立即关闭tcp连接，如果需要复用tcp连接需要显式添加头字段Connection:keep-alive来告诉对方保持长连接；而HTTP1.1默认就是长连接，无需手动添加字段。

2. HTTP1.0规定一个tcp连接只能发送一个请求；而HTTP1.1引入了管道机制，规定一个tcp连接中可以发起多个请求，但是服务器在响应的时候还是会按照处理请求的顺序来进行响应。

3. HTTP1.0中主要使用header中的If-Modified-Since和Expires来作为缓存判断的标准；HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略

4. HTTP1.0不支持Host字段，无法向同一台服务器发起对于多个网站的请求；HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）

5. HTTP1.0对于大文件不支持断点续传，但是HTTP1.1支持将大文件分块chunk进行传输，只要请求或者响应的头部信息中包含Transfer-Encoding字段，那么代表服务端的响应数据将会由未知数量的数据块chunk组成